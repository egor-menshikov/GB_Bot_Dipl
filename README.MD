# Телеграм бот для дипломной работы GB.

### <u>Порядок моих действий.</u>

1) В telegram подключаемся к https://t.me/BotFather, создаем нового бота, выбираем отображаемое имя и имя пользователя.
   Получаем токен доступа к API.
2) Создаем проект в python, устанавливаем фреймворк aiogram, устанавливаем библиотеку python-dotenv.
3) Пишем самый минимальный функционал бота: инициализируем бота и диспетчер(обработчик обновлений, которые бот получает
   с сервера telegram), запускаем прослушку обновлений с сервера telegram,
   прорабатываем реакции на команду */start*, и на простые сообщения вроде *hi*, *bye*.
4) Задействуем dotenv.
5) Вынес хэндлеры в отдельный модуль, добавил пару тестовых команд, создал роутеры для группы и приватных сообщений.
6) Добавил фильтры сообщений в эти роутеры.
7) Добавил хэндлер для администраторов.
8) Добавил метод генерации клавиатур, добавил эти клавиатуры в различные хэндлеры.
9) Добавил машину состояний для админа - добавление товара.
10) Начал работать с библиотекой *SQLAlchemy*: создал структуру таблицы *Product*.
11) Создал саму базу данных на SQLite, механизмы подключения и отключения от нее.


### <u>Заметки.</u>

##### [asyncio](https://docs.python.org/3/library/asyncio.html)

Модуль для создания асинхронных приложений.

* ```async def ...``` Превращает функцию в Coroutine - позволяет функции работать одновременно с другими.
* ```await ...``` Говорит Coroutine где можно встать на паузу и передать контроль другой Coroutine. Ставится только
  перед Awaitable командами.

##### [aiogram](https://docs.aiogram.dev/en/latest/)

Асинхронный фреймворк для создания телеграм ботов.

* ```await bot.delete_webhook(drop_pending_updates=True)``` При развертывании на сервере (когда у бота есть свой url),
  нужно чтобы бот не отвечал на те сообщения, которые пришли, когда он был офлайн.
* ```await message.(answer/reply/send_message(id, text))``` Разные способы отправки сообщений.
* ```@dp.message()``` (Где dp - диспетчер бота) Насколько я понял, заворачиваем наши асинхронные функции в данный
  декоратор, и они будут работать, в данном случае, при получении апдейта типа Message с telegram-сервера. Список
  возможных событий можно посмотреть в официальной документации к telegram ботам.
* Боту можно задавать его возможные команды, которые появятся в кнопке меню и область действия для них (
  scope). ```bot.set_my_commands(commands=список_команд, scope=types.область)```. Если нужно их удалить, то
  используем ```bot.delete_my_commands(scope)```.
* Команда BotCommand состоит из имени и описания, например ```BotCommand(command='menu', description='Открыть меню')```.
* ```from aiogram import F``` [Магический фильтр.](https://docs.aiogram.dev/en/latest/dispatcher/filters/magic_filters.html)
  Пример
  использования: ```@user_private_rt.message(F.text == 'текст')```. В данном случаем мы через атрибуты F получаем доступ
  к полям Message. Из того, что запомнилось - ```~``` - инвертирует результат, т.е. "все, кроме этого
  условия". ```or_f(variants)``` - 'или'.
* [Создание фильтров.](https://docs.aiogram.dev/en/latest/dispatcher/filters/index.html)
* Можно получать от бота экранное меню (клавиатуру) с кнопками, для этого в параметр сообщения ```reply_markup```
  добавляем экземпляр ```ReplyKeyboardMarkup```, в который передаем названия кнопок в формате список списков (по рядам).
  Эти названия будут восприниматься как вводимые сообщения.
* Второй способ добавления клавиатуры - ```ReplyKeyboardBuilder()```. При передаче дополнительно вызвать
  метод ```as_markup()```. Такую клавиатуру можно достраивать от любой другой: ```new_kb.attach(old_kb)```, и дальше
  добавлять новые кнопки.
* Удаление клавиатуры ```reply_markup=ReplyKeyboardRemove()```.
* Можно запрашивать локацию, телефон, создавать голосования, при указании опций ```request...``` после текста кнопки.
* [Форматирование текста.](https://docs.aiogram.dev/en/latest/utils/formatting.html) ```TODO```
* ```fsm_strategy=``` в параметрах диспетчера - стратегия машины состояний. По умолчанию стоит ```USER_IN_CHAT```, т.е.
  для каждого юзера отдельные состояния.
* **Для машины состояний**:
    1) Создаем класс, унаследованный от ```StatesGroup```.
    2) Внутри создаем состояния ```State()```.
    3) В параметрах хэндлеров дополнительно прокидываем ```state: FSMContext```.
    4) В самый первый хэндлер добавим проверку ```StateFilter(None)``` - смотрим, чтобы у пользователя еще не было
       состояний. ```'*'``` - любое состояние.
    5) Встать в режим ожидания, например ```await state.set_state(AddProduct.name)```.
    6) В следующем хэндлере проверяем ```StateFilter(AddProduct.name)```, и заполняем атрибут
       name: ```await state.update_data(name= message.text)```.
    7) Для получения изображений: ```message.photo[-1].file_id``` - в самом высоком разрешении. Каждому изображению в тг
       присваевается свой id, о которому потом можно получить к нему доступ.
    8) Получить словарь со всеми данными: ```await state.get_data()```.
    9) Очистить все состояния после сбора данных: ```await state.clear()```.
    10) ```AddProduct.__all_states__``` - доступ ко всем состояниям текущего FSM.
    11) Для отлова неверных значений дублируем хэндлеры, но оставляем в них поиск только по состоянию, без просмотра
        message.
* Middleware — связующее программное обеспечение, которое помогает приложению и серверу обмениваться друг с другом
  запросами. В aiogram будем использовать два 'слоя' - обрабатывающее запросы сервера до (outer_middleware) и после (
  middleware) фильтров.
* Пример использования: прицепим внутреннее middleware к роутеру
  админа ```admin_rt.message.middleware(CounterMiddleware())```. В самом middleware мы принимаем сам handler, тип
  события (Message), и словарик с его аргументами. Мы создаем переменную counter, добавляем ее в словарь аргументов, и
  возвращаем тот же handler (через await) с обновленным словарем. Теперь для того, чтобы middleware сработало, мы в
  любой handler роутера админа передаем на вход название переменной counter, и имеем к ней доступ.
* Middleware можно также повесить и на Dispatcher. У диспетчера есть тип события update, т.е.
  вообще любое события. Таким образом, можно сделать: ```dp.update.outer_middleware(наше_миддлвэр)``` - такое middleware
  будет подключаться раньше всех абсолютно ко всем событиям бота. В таком случае желательно для типа события (event)
  желательно использовать предка всех событий: ```TelegramObject```.

##### [SQLAlchemy](https://www.sqlalchemy.org/)

ОРМ для работы с SQL-подобными базами данных. Позволяет 'переводить' универсальные запросы, которые мы пишем в коде под
конкретный движок БД, который мы решили использовать.

Вспомогательные библиотеки:

* [aiosqlite](https://aiosqlite.omnilib.dev/en/stable/) - для асинхронной работы с SQLite.
* [asyncpg](https://magicstack.github.io/asyncpg/current/) - то же самое, но для PostgreSQL. Положу ее пока в этот
  раздел.

**Как работать**:

1. См. файл ```database/models.py```: Нужно описать структуру таблиц, подробно писать не буду, но суть - создаем класс
   таблицы, унаследованный
   от ```DeclarativeBase```. Внутри ```__tablename__``` - имя таблицы, а дальше столбцы с аннотацией типов, и
   дополнительными параметрами.
2. См. файл ```database/engine.py```: Далее нужно создать объект движка базы данных, с указанием адреса этой базы
   данных,
   например: ```engine = create_async_engine(os.getenv('DB_LITE'))```. *DB_LITE* здесь - адрес, где хранится БД.
3. См. файл ```database/engine.py```: Создать объект, который будет начинать сессии работы с БД. В нем указываем движок,
   сделанный выше, а также класс этого объекта, в нашем случае асинхронный.
   Пример: ```session_maker = async_sessionmaker(bind=engine, class_=AsyncSession, expire_on_commit=False)```.
4. См. файл ```database/engine.py```: Прописать как минимум одну функцию для создания всех таблиц из ранее созданного
   нами класса. В этом коде функия называется ```create_db()```. При желании также делаем функкию для сброса базы
   данных.
5. См. файл ```app.py```: При запуске бота через диспетчер запускаем функцию и производим какие-то действия при
   выключении бота: ```dp.startup.register(on_startup)``` и ```dp.shutdown.register(on_shutdown)```.

##### [python-dotenv](https://github.com/theskumar/python-dotenv)

Небольшой пакет, который считывает пары ключ-значение из файла .env, и загружает необходимые вашему
приложению переменные среды.

* Прячем токен бота в файл '.env', хранящийся локально.
* ```load_dotenv(find_dotenv())``` Выгружаем переменные из файла в переменные окружения. Достается такая переменная при
  помощи ```os.getenv(name)```.

### <u>Ссылки на материалы.</u>

* [Плейлист по созданию ботов в telegram от Python Hub Studio](https://www.youtube.com/playlist?list=PLNi5HdK6QEmWLtb8gh8pwcFUJCAabqZh_)